# АКОС ИДЗ №4
Садиков Амир

Вариант: 23 *Задача о болтунах*

## Задача

Задача о болтунах. N болтунов имеют телефоны. Они либо неко-
торое (случайное) время ждут звонков, либо звонят друг другу,
чтобы побеседовать. Если телефон случайного абонента занят,
болтун будет звонить другому случайному абоненту, пока ему
кто-нибудь не ответит. Побеседовав некоторое время, болтун или
ждет звонка, или звонит на другой случайный номер.
Создать многопоточное приложение, моделирующее пове-
дение болтунов.
Каждый болтун моделируется отдельным потоком.

## Решение

У нас фиксированне количество болтунов. У них есть какое то либо из состояний:

- ожидание входящего звонка
- попытка дозвона до другого болтуна
- разговор

Телефон болтуна может участвовать только в одном разговоре одновременно. Если болтун занят разговором, он не может принимать входящие вызовы. Все болтуны говорят, управляющий поток отсутствует.

---

Используется модель взаимодействующих равных потоков
Каждый поток выполняет одинаковый код и взаимодействует с другими потоками через разделяемую память. Синхронизация осуществляется с использованием средств POSIX Threads.

---

Писал на 10 баллов, то есть вторая программа

В основной реализации используются следующие синхропримитивы:
- мьютекс `pthread_mutex_t`
- условные переменные `pthread_cond_t`
- атомарные переменные `atomic_int`

Для каждого болтуна создаётся отдельная условная переменная, позволяющая реализовать ожидание входящего звонка без активного ожидания. Состояние занятости телефонов хранится в массиве переменных.

Два спобоса запустить программу
- через аргументы командной строки;
- через конфигурационный файл (ключ `-c`).

Результаты работы выводятся на экран и записываются в логи.

---

Альтернативная версия программы построена на другой модели синхронизации:
- У болтунов есть три сосятония (`WAITING`, `CALLING`, `TALKING`);
- синхронизация осуществляется только с помощью мьютекса;
- условные переменные и атомарные типы не используются.

Работает ввод параметров через командную строку и конфиг, ну и логи тож работают

---

Входные параметры программы:
- `N` количество болтунов;
- `LOGFILE` имя файла для записи журнала.

Параметры могут задаваться
- напрямую в командной строке;
- через конфигурационный файл следующего формата:

```
N=5
LOGFILE=log.txt
```

---

В проге использовал `rand()` для:
- выбора действия болтуна (ожидание или звонок);
- выбора абонента для звонка;
- задания длительности разговора (1-3 секунды);
- задания задержек между действиями.

Все выполняется рандомно

---

Компиляция

```
gcc -std=c11 -pthread chatters_cond.c -o chatters_cond
gcc -std=c11 -pthread chatters_mutex.c -o chatters_mutex
```

Запуск основной реализации

```
./chatters 5 log.txt
```

или

```
./chatters -c config.txt
```

Запуск альтернативной реализации

```
./chatters_alt 5 log_alt.txt
```

или

```
./chatters_alt -c config.txt
```

---

Программа без ошибок завершает работу при получении сигнала `SIGINT` (Ctrl+C). Все потоки завершают выполнение, освобождаются ресурсы и офаются логи

---

Две программы выводят одинаковые данные, разлчитается только методы реализации
- ни один болтун не участвует более чем в одном разговоре;
- отсутствуют взаимные блокировки;
- корректно моделируется конкурентный доступ к телефонной линии.

Различие заключается в используемых синхропримитивах и организации логики взаимодействия потоков.

---

В ходе выполнения работы была разработана многопоточная модель задачи о болтунах с использованием POSIX Threads. Реализованы две версии программы с различными механизмами синхронизации и поддержкой конфигурационных файлов. Все требования варианта и критериев оценивания выполнены.
